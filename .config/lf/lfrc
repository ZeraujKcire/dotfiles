# vim:foldmethod=marker:foldmarker={{,}}

#  ██       ████████
# ░██      ░██░░░░░ 
# ░██      ░██      
# ░██      ░███████ 
# ░██      ░██░░░░  
# ░██      ░██      
# ░████████░██      
# ░░░░░░░░ ░░       

# interpreter for shell commands
set shell sh
# set preview
set cleaner '~/.config/lf/cleaner'
set previewer '~/.config/lf/scope'
# set nopreview
# set scrolloff=18

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

# leave some space at the top and the bottom of the screen
set scrolloff 18

# NUMBER OF SPACES IN TABS

# use enter for shell commands
map <enter> shell

# execute current file (must be executable)
map x $$f
map X !$f

# dedicated keys for file opener actions
map o &mimeopen $f
map O $mimeopen --ask $f

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.

# cmd open &xdg-open $f
cmd open ${{
    test -L $f && f=$(readlink -f $f)
    case $(file --mime-type $f -b) in
        text/*) $EDITOR $fx;;
        *) for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}

# define a custom 'rename' command without prompt for overwrite
cmd rename %[ -e $1 ] && printf "FILE EXISTS" || mv $f $1

# make sure trash folder exists
# %mkdir -p ~/.trash

# move current file or selected files to trash folder
# (also see 'man mv' for backup/overwrite options)
# cmd trash %set -f; mv $fx ~/.trash

# cmd removedir %trash-put $fx
# cmd removedir ${{
     # for file in "$fx"
     # do
       # trash-put "$file"
     # don
   # donee
# }}

cmd trash %set -f;trash $fx

cmd gototrash %set hidden!;set -f;cd ~/.local/share/Trash/files/

# define a custom 'delete' command
cmd delete ${{
    set -f
    printf "$fx\n"
    printf "delete?[y/n]"
    read ans
    [ $ans = "y" ] && rm -rf $fx
}}
# cmd delete %set -f;rm -rf $fx

# use '<delete>' key for either 'trash' or 'delete' command
# map <delete> trash
# map <delete> delete

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
    esac
}}

# compress current file or selected files with tar and gunzip
cmd compress_tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd compress_zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}

#{{ cmd updir $
cmd updir %cd ..
#}}

cmd mkdir ${{
    set -f
    printf "NEW DIRECTORY NAME: "
    read name
    mkdir $name
}}

cmd mkfile ${{
    printf "NEW FILE NAME: "
    read name
    touch $name
    $EDITOR $name
}}

cmd chmod ${{
		printf "Mode of Bits: "
		read ans
		for file in "$fx"
		do
			chmod $ans $file
		done
		lf -remote 'send reload'
}} 

#{{ cmd terminal_window $
cmd terminal_window &kitty 'lf' && cd $f
#}}

# cmd gotoconfig ${{
  # printf "CONFIG FOLDER: "
  # read name
  # directory = ".config/" + $name
  # cd ~
  # cd $directory
# }}

cmd mount_usb $sudo mount /dev/sdb1 ~/usb
# cmd umount_usb $sudo umount -l ~/usb

# Markdown {{
cmd create_md %cp ~/Plantillas/MARKDOWN/markdown.md .
#}}

# Latex {{
cmd pdflatexfolder %cp -R ~/Plantillas/LATEX_1/ .
cmd xelatexfolder  %cp -R ~/Plantillas/LATEX_2/ .
cmd practica_pdf   %cp -R ~/Plantillas/PRACTICA_1 .
cmd practica_xel   %cp -R ~/Plantillas/PRACTICA_2 .
cmd practica_xel_R %cp -R ~/Plantillas/PRACTICA_R .
cmd xelatex_R      %cp -R ~/Plantillas/LATEX_R .
cmd beamer_pdf     %cp -R ~/Plantillas/LATEX_BEAMER .
cmd tarea_pdf      %cp -R ~/Plantillas/LATEX_TAREAS .
cmd tikz_tex       %cp -R ~/Plantillas/LATEX_TIKZ/ .
cmd tikz_tex_norm  %cp -R ~/Plantillas/LATEX_TIKZ_NORMAL/ .
cmd license        %cp -R ~/Plantillas/GIT/LICENSE.txt .
# cmd clear_tex      %find . -type f ! -name '*.tex' ! -name '*.sty' ! -name '*.pdf' ! -name '*.bib' ! -name '*.txt' ! -name '*.doc*' ! -name '*.png' ! -name '*.PNG' ! -name '*.ods' ! -name '*.r' ! -name '*.R' ! -name '*.jpeg' -delete
cmd clear_tex %find . -regextype posix-egrep -regex ".*\.(aux|log|nav|out|snm|toc|bbl|blg)$" -type f -delete
#}} 

#{{ CLEAN BINDINGS.
map +
map -
map c
map d
map dd
map e
map gt
map h
map j
map k
map l
map m
map md
map mf
map mlb
map mlp
map mmd
map mpp
map mpr
map mpx
map mlx
map mta
map mlr
map mti
map mlt
map mli
map r
map ñ
map J
map K
map L
map mti
map R
map <c-r>
map <c-d>
map <a-r>
#}}

#{{ KEYBINDINGS.
map + :set preview
map - :set nopreview
map . set hidden!
map c cut
map dd trash
map e extract
map gt gototrash
map j updir
# map H umount_usb
map h mount_usb
map k down
map l up
map md mkdir
map mf mkfile
map mlb beamer_pdf
map mlp pdflatexfolder
map mpp practica_pdf
map mpr practica_xel_R
map mpx practica_xel
map mlx xelatexfolder
map mmd create_md
map mta tarea_pdf
map mti tikz_tex
map mlt tikz_tex_norm
map mlr xelatex_R
map mli license
map r $lf -remote "send $id push :rename<space>'$(basename $f | sed 's/.*\./\./g')'<home><right><right><right><right><right><right><right><right>"
map <c-r> $lf -remote "send $id push :rename<space>'$(basename $f | sed 's/\..*/\./g')'<left>"
map R $lf -remote "send $id push :rename<space>''<left>"
map <a-r> $lf -remote "send $id push :rename<space>'$(basename $f)'<left><left><left><left><left>"
map ñ open
map J cd ~
map K bottom
map L top
map W terminal_window
map x chmod
map <a-t> clear_tex
map <c-d> reload
#}}
